# sock如何实现"继承"

在网络编程里，我们经常会看到“子进程继承了父进程的socket”这样的说法。这个“继承”并不是面向对象中的类继承，而是操作系统在创建进程
时对文件描述符的一种复制机制。理解这一机制对于编写多进程服务器、正确关闭连接、避免资源泄漏都至关重要。

## 从 `fork()` 说起：文件描述符表的复制

当进程调用 `fork()` 时，操作系统会：

1. **复制父进程的文件描述符表**：子进程得到一份新的表，但表项内容与父进程完全相同，每个表项都指向同一个内核对象（包括socket）。
2. **共享同一个内核socket对象**：socket 的内核结构体包含发送、接收缓冲区、状态机、引用计数等信息。父子进程共享这些状态，因此无论
   哪个进程读写，看到的都是同一条连接的数据。
3. **引用计数 +1**：内核对象维护一个引用计数，用于记录多少个文件描述符指向自己。只有引用计数降为 0 时，内核才会真正释放 socket 并发
   送 FIN/RST。

这个机制保证了：父进程在 `fork()` 之后可以把处理连接的工作交给子进程，而无需重新建立网络连接。

## 继承带来的实际效果

在多进程服务器中常见的模式是：

1. 父进程创建监听 socket（`listen_fd`），调用 `bind`、`listen`。
2. 调用 `fork()`。此时 `listen_fd` 在父子进程中都有效，两者都能调用 `accept()`。
3. 子进程从 `accept()` 得到新的已连接 socket 后，可以选择继续 `fork()` 出更小的工作进程，或者直接在当前进程中处理读写。

由于继承的是同一个内核对象，需要注意以下事项：

- **关闭顺序**：当子进程完成通信后，应调用 `close(conn_fd)`。父进程也要在适当的时候关闭它持有的同一个 `conn_fd`，否则连接会一直存在于
  CLOSE_WAIT 状态。监听 socket 亦然，除非确认不再需要，否则不要在所有进程中关闭它。
- **避免重复处理**：多个进程同时对同一个已连接 socket 读写会造成数据竞争。通常会通过 `fork()` 后立即在父进程中关闭 `conn_fd`，只让子
  进程保留它；而子进程则关闭 `listen_fd`，避免误用。
- **信号与退出**：当子进程意外退出而没有关闭 socket 时，引用计数会自动减一。如果所有进程都退出，内核会回收资源并向对端发送 RST/FIN。

## `exec()` 后的继承

如果 `fork()` 之后调用 `exec()` 执行新的程序，默认情况下已经打开的文件描述符会被继承到新程序中。这就是“预先在父进程里打开 socket，再
把连接交给另一个程序处理”的经典做法。若想阻止这种继承，可以在 `fork()` 前为描述符设置 `FD_CLOEXEC` 标志，或者使用 `SOCK_CLOEXEC` 标志
创建 socket。

## 多进程模型与负载均衡

“继承”出来的监听 socket 可以实现简单的负载均衡：多个子进程阻塞在同一个 `accept()` 上，内核在有新连接时会唤醒其中一个进程，让它得到
新的连接。这种模型称为 **accept 竞争（accept mutex）**。为了避免惊群效应，现代内核会采用排他唤醒等优化手段；Nginx 等服务器还会通过
自旋锁或共享内存控制哪个进程可以进入 `accept()`。

## 与线程的对比

线程之间天然共享文件描述符表，因此无需“继承”概念。只要在线程中持有 socket 的整数描述符，就可以直接读写。正是因为进程之间需要这种
复制机制，才会有“继承”这一说法。

## 总结

所谓socket的“继承”，本质是 `fork()` 时复制文件描述符表，让父子进程指向同一个内核socket对象。理解其细节，就能：

- 正确设计多进程网络服务的结构；
- 避免因为未关闭描述符而导致连接泄漏；
- 在需要时将连接交接给其他程序或进程处理。

掌握这一机制，是编写稳定可靠网络服务的基本功。

---

*本文档为《网络101》系列的一部分*
