# 对于异常情况的处理

网络传输并不总是一帆风顺。链路抖动、对端宕机、应用程序 Bug 都可能让通信中断。本节从 TCP 和 UDP 两种协议的特点出发，梳理常见异常以及
对应的处理策略。

## TCP：可靠性带来的状态变化

TCP 保证可靠性，因此它会用一系列状态机和错误码告诉我们发生了什么。

### 常见异常

- **连接建立失败**：`connect()` 返回 `ECONNREFUSED`（对端端口无人监听）、`ETIMEDOUT`（对端不响应）。应用需要重试或回退到备用地址。
- **发送异常**：
  - `send()` 返回 `EPIPE` 并产生 `SIGPIPE`，表示对端已经关闭连接；
  - 返回值小于请求发送的字节数时，需要继续发送剩余部分；
  - 阻塞模式下如果对端迟迟不读数据，内核缓冲区会被占满，`send()` 会阻塞或返回 `EAGAIN`（在非阻塞模式下）。
- **接收异常**：
  - `recv()` 返回 0：对端优雅关闭（FIN）；
  - `recv()` 返回 `ECONNRESET`：收到 RST，说明对端异常退出或发送了错误的序列号；
  - 超时：为 socket 设置 `SO_RCVTIMEO` 后，超过时间会得到 `EAGAIN/EWOULDBLOCK`。

### 处理策略

- **超时重试**：为阻塞的 `connect`、`recv`、`send` 设置超时，避免线程挂死。重试时要注意退避策略，防止雪崩。
- **心跳保活**：开启 `SO_KEEPALIVE` 或自行定时发送心跳包，以便尽早发现死连接。对于实时业务可缩短探测间隔，并在应用层设置更严格的超时。
- **错误分类处理**：区分“暂时性错误”（`EAGAIN`、`EINTR`）与“致命错误”（`ECONNRESET`、`EPIPE`），仅对前者进行重试。
- **资源回收**：在捕获异常后及时关闭 socket，释放文件描述符和内核资源，避免泄漏导致“too many open files”。

## UDP：简单但“不可靠”

UDP 不维护连接状态，内核几乎不会告诉你“出错了”。常见异常情况包括：

- **数据丢失或乱序**：应用可能收不到某个数据报，也可能先收到后发出的报文。需要应用层自行添加序列号和重传机制。
- **ICMP 错误报告**：如果向不存在的端口发送数据，在 Linux 上下一次 `sendto` 可能收到 `ECONNREFUSED`。但并非所有平台都会报告。
- **缓冲区溢出**：接收端来不及处理时，内核会丢弃数据报，并在 `recvfrom` 中返回 `EMSGSIZE` 或 `EAGAIN`（非阻塞模式）。
- **大小超限**：`sendto` 数据超过 `SO_SNDBUF` 或路径 MTU 时，内核可能返回 `EMSGSIZE`，提示需要拆分数据。

处理策略：

- **应用层协议设计**：加入序列号、确认与超时重传逻辑，把可靠性需求移到业务层。
- **缓冲区调整**：通过 `SO_RCVBUF`、`SO_SNDBUF` 增大缓冲区，配合高性能 I/O 减少丢包。
- **速率控制**：根据实际带宽和处理能力，采用令牌桶等算法限制发送速率，避免突发流量压垮网络。
- **错误监控**：读取 `getsockopt(SO_ERROR)` 或通过日志分析 ICMP 回显，辅助定位网络问题。

## 通用的健壮性建议

- **输入校验**：无论 TCP 还是 UDP，都要对收到的数据进行边界检查和格式校验，避免异常数据导致服务崩溃。
- **防御性编程**：使用 `while` 循环重试被 `EINTR` 中断的系统调用；在任何可能失败的调用后检查返回值。
- **监控与告警**：统计失败率、超时次数、重传次数，结合抓包工具定位问题，才能持续提升服务质量。

网络世界充满不确定性，能够优雅地处理异常，才能让服务在复杂环境下保持稳定。

---

*本文档为《网络101》系列的一部分*
