# 使用socket进行数据传输

理解 TCP 和 UDP 的差异，最直接的方式就是亲手用 socket 发送、接收数据。本节从实战角度出发，带你梳理这两种协议各自的调用流程、常见注
意事项以及关键的 socket 选项。

## TCP：面向连接的字节流

TCP 提供可靠、有序、基于字节流的数据传输。典型的通信流程如下：

1. **服务器端**
   - `socket(AF_INET, SOCK_STREAM, 0)`：创建监听 socket；
   - `bind()`：绑定本地 IP + 端口；
   - `listen()`：进入监听状态，准备接受连接；
   - `accept()`：从已完成队列中取出一个连接，返回新的已连接 socket；
   - `recv()/read()`、`send()/write()`：在已连接 socket 上收发字节流；
   - `close()`：通信完成后关闭连接。
2. **客户端**
   - `socket(AF_INET, SOCK_STREAM, 0)`：创建 socket；
   - `connect()`：发起三次握手，建立连接；
   - `send()` / `recv()`：发送、接收字节流；
   - `close()`：主动断开连接。

```mermaid
flowchart LR
    subgraph TCP 面向连接
        T1[创建监听 socket]
        T2[bind 绑定地址]
        T3[listen 进入监听]
        T4[accept 拿到连接]
        T5[send/recv 循环]
        T6[close 优雅关闭]
        T1 --> T2 --> T3 --> T4 --> T5 --> T6
    end
    subgraph UDP 无连接
        U1[socket 创建数据报 socket]
        U2[bind 可选绑定本地端口]
        U3[sendto 直接发送]
        U4[recvfrom 获取报文]
        U5[close 释放资源]
        U1 --> U2 --> U3 --> U4 --> U5
    end
    T5 -. 对端 -> U4
    U3 -. 对端 -> T5
```

> **提示**：`recv()` 不保证一次读取到完整的业务消息，它只保证会返回“当前接收到的字节”。因此应用层需要设计消息分隔方式，例如固定长
度、定长头部+正文、特殊分隔符或基于序列化协议。

### 一个最小的 TCP 示例

```python
# tcp_server.py
import socket

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as srv:
    srv.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    srv.bind(("0.0.0.0", 9000))
    srv.listen()
    conn, addr = srv.accept()
    with conn:
        print("connected from", addr)
        data = conn.recv(1024)
        conn.sendall(data.upper())

# tcp_client.py
import socket

with socket.create_connection(("127.0.0.1", 9000)) as cli:
    cli.sendall(b"hello")
    print(cli.recv(1024))  # b'HELLO'
```

`sendall()` 会在内部循环调用 `send()`，直到所有数据都写入内核缓冲区；这也是推荐的写法。

## UDP：无连接的数据报

UDP 是无连接的、基于数据报的协议。它不保证可靠性，但开销更低，适合“允许偶尔丢包但追求速度”的场景。

典型流程如下：

- **服务器/接收端**
  1. `socket(AF_INET, SOCK_DGRAM, 0)` 创建数据报 socket；
  2. `bind()` 绑定本地端口；
  3. `recvfrom(bufsize)` 接收数据，同时获得发送者地址；
  4. 根据需要用 `sendto(data, addr)` 回复。
- **客户端/发送端**
  1. `socket(AF_INET, SOCK_DGRAM, 0)`；
  2. 可选：`connect()` 绑定默认目标（使 `send()`、`recv()` 也适用于 UDP）；
  3. `sendto()` 或 `send()` 直接把整块数据报发出去；
  4. `close()` 释放资源。

UDP 不存在“粘包”问题，因为每次 `recvfrom` 返回的就是一个完整的数据报；但如果报文超过了路径 MTU，IP 层可能分片，丢失任何一片都会导致整
个报文作废。

### 一个简洁的 UDP 示例

```python
# udp_echo.py
import socket

with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
    sock.bind(("0.0.0.0", 9001))
    while True:
        data, addr = sock.recvfrom(2048)
        print("recv", data, "from", addr)
        sock.sendto(data.upper(), addr)

# 客户端
with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as cli:
    cli.sendto(b"hello", ("127.0.0.1", 9001))
    print(cli.recvfrom(2048))
```

## 常用 socket 选项与模式

- `SO_REUSEADDR` / `SO_REUSEPORT`：允许端口快速复用，便于重启服务或多进程监听同一端口。
- `SO_RCVBUF` / `SO_SNDBUF`：调整内核缓冲区大小，影响吞吐和内存占用。
- `SO_RCVTIMEO` / `SO_SNDTIMEO`：设置阻塞调用的超时时间，避免无限等待。
- 非阻塞模式 + `select/poll/epoll`：构建高并发服务器常用的事件驱动模型。
- `TCP_NODELAY`：关闭 Nagle 算法，让小数据包也能立刻发送，常用于即时性要求高的业务。

掌握这些调用与选项，就能根据业务需求选择合适的协议、编写出行为可控的数据传输逻辑。接下来，我们将深入讨论在网络传输中可能出现的异常以
及如何处理。

---

*本文档为《网络101》系列的一部分*
