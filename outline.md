第1章 网络基础：探索网络的起点 1

1.1 TCP/IP四层网络是什么？ 2

1.1.1 TCP/IP四层网络 2

1.1.2 两台计算机互连 5

1.1.3 小结 8

1.2 怎样使用Wireshark抓包？ 9

1.3 如何使用Wireshark定位timeout问题 22

1.3.1 问题背景 22

1.3.2 排查方案 23

1.3.3 原因 26

1.3.4 小结 27

第2章 网络层和网络接口层：架起连接的桥梁 28

2.1 为什么我们家里的IP地址都是192.168开头的？ 29

2.1.1 IP地址是什么？ 29

2.1.2 IP地址的分类 30

2.1.3 IP地址不够用了吗？ 31

2.1.4 查询自己的公网IP地址 35

2.1.5 小结 36

2.2 为什么我在公司访问不了家里的计算机？ 37

2.2.1 NAT的工作原理 37

2.2.2 NAPT的工作原理 39

2.2.3 内网穿透是什么？ 42

2.2.4 小结 46

2.3 ping不通，网络就一定不可用吗？ 46

2.3.1 ICMP是什么？ 47

2.3.2 ICMP报文格式 47

2.3.3 ICMP和IP的关系 49

2.3.4 ICMP抓包 50

2.3.5 小结 54

2.4 路由器、集线器、交换机有什么区别？ 54

2.4.1 什么是集线器？ 55

2.4.2 什么是交换机？ 57

2.4.3 什么是路由器？ 61

2.4.4 小结 64

第3章 传输层：数据流动内幕 65

3.1 socket到底是什么？ 66

3.1.1 socket如何实现网络通信？ 72

3.1.2 sock如何实现“继承”？ 76

3.1.3 小结 76

3.2 TCP和UDP有什么区别？ 77

3.2.1 使用socket进行数据传输 77

3.2.2 对于异常情况的处理 78

3.2.3 用UDP就一定比用TCP快吗？ 82

3.2.4 小结 84

3.3 代码执行send成功后，数据就发出去了吗？ 84

3.3.1 socket缓冲区 84

3.3.2 TCP部分 85

3.3.3 UDP部分 92

3.4 TCP两次挥手，你见过吗？那四次握手呢？ 94

3.4.1 TCP四次挥手 94

3.4.2 TCP三次挥手 101

3.4.3 TCP两次挥手 102

3.4.4 TCP四次握手 108

3.4.5 小结 110

3.5 没有accept，能建立TCP连接吗？ 110

3.5.1 三次握手的细节分析 112

3.5.2 小结 120

3.6 收到RST就一定会断开TCP连接吗？ 120

3.6.1 出现RST的场景有哪些？ 122

3.6.2 收到RST就一定会断开连接吗? 128

3.6.3 小结 132

3.7 服务端没执行bind，却执行了listen，会怎样？ 132

3.7.1 bind的作用 132

3.7.2 不执行bind会怎样 133

3.7.3 小结 135

3.8 TCP粘包是什么?数据包：我只是犯了每个数据包都会犯的错 135

3.8.1 数据分段 136

3.8.2 MTU和MSS有什么区别？ 137

3.8.3 什么是粘包？ 138

3.8.4 为什么会出现粘包？ 139

3.8.5 为什么要组装发送的数据？ 139

3.8.6 关掉Nagle算法就不会粘包了吗？ 141

3.8.7 怎样处理粘包？ 142

3.8.8 UDP 会粘包吗？ 143

3.8.9 IP层有粘包问题吗? 145

3.8.10 小结 148

3.9 为什么IP层会分片，TCP层也要分段？ 148

3.9.1 如何查看MSS？ 148

3.9.2 如何查看MTU？ 149

3.9.3 为什么MTU一般是1500？ 150

3.9.4 TCP层分段了，IP层就一定不会分片了吗？ 151

3.9.5 IP层怎样做到不分片？ 152

3.9.6 小结 154

3.10 连接一个IP地址不存在的主机时，握手过程是怎样的？ 154

3.10.1 正常情况下的握手过程是怎样的？ 155

3.10.2 连IP地址存在但端口号不存在的主机的握手过程 163

3.10.3 小结 166

第4章 应用层：网络应用交互的奇妙旅程 167

4.1 HTTP是什么？ 168

4.1.1 HTTP报文格式 168

4.1.2 报文信息解读 170

4.1.3 小结 182

4.2 502问题怎么排查？ 183

4.2.1 HTTP状态码 183

4.2.2 网关的作用 184

4.2.3 Nginx返回5xx状态码 185

4.2.4 产生502的常见原因 186

4.2.5 小结 190

4.3 既然有HTTP，为什么还要有RPC？ 191

4.3.1 从TCP聊起 191

4.3.2 使用纯裸TCP会有什么问题？ 191

4.3.3 HTTP和RPC 192

4.3.4 小结 197

4.4 为什么有了HTTP，还要有websocket协议？ 197

4.4.1 使用HTTP不断轮询 198

4.4.2 长轮询 199

4.4.3 websocket是什么？ 201

4.4.4 怎样建立websocket连接？ 201

4.4.5 websocket抓包 203

4.4.6 websocket的消息格式 205

4.4.7 websocket的使用场景 207

4.4.8 小结 207

4.5 刚插上网线，计算机怎么知道自己的IP地址是什么？ 208

4.5.1 DHCP是什么？ 209

4.5.2 DHCP的工作原理 210

4.5.3 DHCP抓包 211

4.5.4 为什么DHCP用UDP，能不能改用TCP？ 213

4.5.5 为什么第二阶段不是广播，而是单播？ 213

4.5.6 是不是每次联网都要经历DHCP四个阶段？ 214

4.5.7 DHCP分配下来的IP地址一定不会重复吗？ 215

4.5.8 小结 217

4.6 HTTPS里公钥加密的内容，为什么不能用公钥解密？ 217

4.6.1 对称加密和非对称加密 217

4.6.2 HTTPS的加密原理 220

4.6.3 小结 227

4.7 为什么我抓不到baidu的数据包？ 227

4.7.1 为什么没能抓到数据包？ 228

4.7.2 解密数据包 230

4.7.3 HTTPS握手过程 232

4.7.4 怎样得到pre_master？ 233

4.7.5 ssl.key文件内容 233

4.7.6 小结 236

4.8 DNS中有哪些值得学习的优秀设计？ 236

4.8.1 为什么要有DNS？ 236

4.8.2 URL的层次结构 238

4.8.3 DNS的原理 239

4.8.4 抓包 246

4.8.5 小结 248

4.9 听说DNS根服务器只有13台，这科学吗？ 248

4.9.1 DNS是基于UDP的应用层协议吗？ 249

4.9.2 为什么有UDP了还要用到TCP？ 251

4.9.3 既然TCP那么好，为什么不全用TCP？ 252

4.9.4 迭代查询和递归查询是什么？ 252

4.9.5 迭代查询和递归查询的报文特征 253

4.9.6 DNS的IPv4根域只有13个吗？ 254

4.9.7 小结 258

4.10 如果没有 SSH，我们用什么登录服务器？ 259

4.10.1 SSH是什么？ 259

4.10.2 用telnet登录服务器 259

4.10.3 用telnet登录服务器有什么问题？ 261

4.10.4 SSH的原理 263

4.10.5 网络抓包 265

4.10.6 小结 268

4.11 断网了还能ping通127.0.0.1吗？为什么？ 268

4.11.1 什么是127.0.0.1？ 269

4.11.2 什么是ping？ 270

4.11.3 TCP发数据和ping的区别 271

4.11.4 ping回环地址和ping本机地址有什么区别？ 273

4.11.5 127.0.0.1与localhost以及0.0.0.0有区别吗？ 275

4.11.6 小结 276

4.12 能ping通，就代表TCP一定能连通吗？ 276

4.12.1 网络路径 277

4.12.2 路径由什么决定？ 278

4.12.3 TCP和ping走的网络路径一样吗？ 282

4.12.4 同样都用TCP，数据包走的网络路径一样吗？ 283

4.12.5 利用这个知识点排查问题 283

4.12.6 小结 284

4.13 用了TCP，就一定不会丢包吗？ 285

4.13.1 数据包的发送流程 285

4.13.2 建立连接时丢包 287

4.13.3 流量控制丢包 288

4.13.4 网卡丢包 290

4.13.5 接收缓冲区丢包 293

4.13.6 两端之间的网络丢包 296

4.13.7 发生丢包了怎么办？ 298

4.13.8 这类丢包问题怎么解决？ 300

4.13.9 小结 301


第5章 网络编程：代码与网络的虚拟工艺 302

5.1 socket是并发安全的吗？ 303

5.1.1 写TCP socket是线程安全的吗？ 305

5.1.2 读TCP socket是线程安全的吗？ 309

5.1.3 读写UDP socket是线程安全的吗？ 310

5.1.4 小结 314

5.2 游戏服务器为什么能支持海量玩家同时在线？ 314

5.2.1 I/O多路复用 316

5.2.2 select和poll 317

5.2.3 epoll 319

5.2.4 epoll的内核实现 321

5.2.5 小结 323

5.3 用了socket就一定要走网络协议栈吗？ 324

5.3.1 基于sidecar的服务架构 325

5.3.2 unix domain socket是什么？ 327

5.3.3 unix domain socket内核实现 328

5.3.4 还有哪些使用场景？ 331

5.3.5 小结 332

5.4 《原神》主要用的是TCP还是UDP？ 333

5.4.1 为什么要用UDP而不是TCP? 333

5.4.2 UDP如何变得可靠？ 335

5.4.3 KCP的功能 335

5.4.4 为什么有了TCP还要有KCP? 337

5.4.5 KCP的实现 339

5.4.6 小结 343

5.5 KCP很强，但遇到QoS问题，该怎么办呢？ 344

5.5.1 QoS是什么？ 344

5.5.2 控制QoS的原理 345

5.5.3 KCP为什么会有 QoS 问题？ 348

5.5.4 KCP如何应对QoS导致的丢包问题？ 349

5.5.5 QoS的设计有哪些地方值得借鉴？ 350

5.5.6 小结 351

5.6 网络通信中的序列化和反序列化是什么？ 351

5.6.1 XML 352

5.6.2 JSON 353

5.6.3 protobuf 355

5.6.4 Thrift 358

5.6.5 小结 359

5.7 protobuf的数据怎么看？ 359

5.7.1 protobuf怎样组织基础数据？ 361

5.7.2 protobuf怎样组织数组类型数据？ 364

5.7.3 protobuf怎样组织数组内嵌结构体？ 365

5.7.4 protobuf做了哪些优化？ 366

5.7.5 更好地阅读protobuf 数据的方法 368

5.7.6 小结 368

5.8 CDN是什么？用了CDN就一定比不用更快吗？ 368

5.8.1 CDN是什么？ 369

5.8.2 CDN的工作原理 370

5.8.3 为什么要那么麻烦加一个CNAME？ 373

5.8.4 怎样知道哪个服务器IP地址离调用方“最近”？ 373

5.8.5 回源是什么？ 374

5.8.6 怎样判断是否发生回源？ 375

5.8.7 用了CDN一定比不用更快吗？ 377

5.8.8 什么情况下不应该使用CDN？ 379

5.8.9 小结 380



